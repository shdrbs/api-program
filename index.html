<!DOCTYPE html>
<html lang="ko">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>API 탭 매니저</title>
		<link rel="stylesheet" href="./style.css" />
		<script src="https://cdn.jsdelivr.net/npm/monaco-editor@0.45.0/min/vs/loader.js"></script>
	</head>
	<body>
		<div class="app-shell">
			<header class="app-header">
				<div>
					<h1>API 탭 매니저</h1>
					<p>API 요청을 생성하고 관리하세요.</p>
				</div>
			</header>

			<div class="main-layout">
				<aside class="sidebar">
					<div class="sidebar-header">
						<h2>요청 목록</h2>
						<button id="newRequestBtn" type="button" class="new-request-btn" title="새 요청 추가">+</button>
					</div>
					<div id="requestList" class="request-list"></div>
					<div id="emptyState" class="empty-state hidden">아직 저장된 항목이 없습니다.</div>
					<div class="sidebar-footer">
						<button id="clearButton" type="button" class="ghost-btn">전체 삭제</button>
					</div>
				</aside>

				<main class="main-content">
					<section class="entry-form hidden" id="entryFormSection">
						<form id="entryForm">
							<div class="field">
								<label for="titleInput">Title</label>
								<input id="titleInput" type="text" placeholder="예) 사용자 조회" required />
							</div>
							<div class="field">
								<label for="methodSelect">Method</label>
								<select id="methodSelect" required>
									<option value="GET">GET</option>
									<option value="POST">POST</option>
									<option value="PUT">PUT</option>
									<option value="PATCH">PATCH</option>
									<option value="DELETE">DELETE</option>
								</select>
							</div>
							<div class="field">
								<label for="urlInput">URL</label>
								<input id="urlInput" type="url" placeholder="https://api.example.com/users" required />
							</div>
							<div class="field">
								<label>Headers</label>
								<div id="headersList" class="headers-list"></div>
								<button type="button" id="addHeaderBtn" class="ghost-btn slim-btn" aria-label="헤더 추가">
									헤더 추가
								</button>
								<small class="help-text">Key/Value 쌍으로 입력하고 필요 없는 항목은 삭제하세요.</small>
							</div>
							<div class="field">
								<label for="apiKeyInput">API Key</label>
								<input id="apiKeyInput" type="text" placeholder="예) sk_live_xxx" />
								<small class="help-text">전송 시 기본 `X-API-Key` 헤더로 포함됩니다.</small>
							</div>
					<div class="field">
						<div class="json-label-container">
							<label for="jsonInput">Json-data</label>
							<button type="button" id="formatJsonInputBtn" class="format-json-btn" title="JSON 포맷팅 (Ctrl+Shift+F)">포맷</button>
						</div>
						<div id="jsonInput" class="monaco-editor-container"></div>
					</div>
							<button type="submit" class="primary-btn">추가</button>
						</form>
					</section>

					<div id="tabDetails" class="tab-details hidden">
						<!-- 동적으로 생성됨 -->
					</div>
				</main>
			</div>
		</div>

		<script>
			(() => {
				// Monaco Editor 초기화
				let monacoEditorInstances = {};
				let monacoLoaded = false;

				const initMonacoEditor = async (containerId, initialValue = '') => {
					return new Promise((resolve) => {
						// Monaco가 이미 로드되었는지 확인
						if (typeof monaco !== 'undefined' && monaco.editor) {
							createEditorInstance(containerId, initialValue, resolve);
							return;
						}

						// Monaco 로드
						if (!monacoLoaded) {
							monacoLoaded = true;
							// Electron 환경에서 require 충돌 방지
							const loaderScript = document.createElement('script');
							loaderScript.src = 'https://cdn.jsdelivr.net/npm/monaco-editor@0.45.0/min/vs/loader.js';
							loaderScript.onload = () => {
								// require를 별도 변수로 저장 (Electron의 require와 충돌 방지)
								const requireMonaco = window.require || require;
								requireMonaco.config({ paths: { vs: 'https://cdn.jsdelivr.net/npm/monaco-editor@0.45.0/min/vs' } });
								requireMonaco(['vs/editor/editor.main'], () => {
									createEditorInstance(containerId, initialValue, resolve);
								});
							};
							document.head.appendChild(loaderScript);
						} else {
							// 이미 로딩 중이면 대기
							const checkMonaco = setInterval(() => {
								if (typeof monaco !== 'undefined' && monaco.editor) {
									clearInterval(checkMonaco);
									createEditorInstance(containerId, initialValue, resolve);
								}
							}, 100);
						}
					});
				};

				const createEditorInstance = (containerId, initialValue, resolve) => {
					const container = document.getElementById(containerId);
					if (!container) {
						resolve(null);
						return;
					}

					// 기존 인스턴스가 있으면 제거
					if (monacoEditorInstances[containerId]) {
						monacoEditorInstances[containerId].dispose();
					}

					const editor = monaco.editor.create(container, {
						value: initialValue,
						language: 'json',
						theme: 'vs',
						automaticLayout: true,
						minimap: { enabled: false },
						scrollBeyondLastLine: false,
						fontSize: 13,
						fontFamily: "'Courier New', monospace",
						wordWrap: 'on',
						formatOnPaste: true,
						formatOnType: true,
						tabSize: 4,
						insertSpaces: true,
					});

					// 포맷 단축키
					editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyMod.Shift | monaco.KeyCode.KeyF, () => {
						editor.getAction('editor.action.formatDocument').run();
					});

					monacoEditorInstances[containerId] = editor;
					resolve(editor);
				};

				const getMonacoValue = (containerId) => {
					const editor = monacoEditorInstances[containerId];
					return editor ? editor.getValue() : '';
				};

				const setMonacoValue = (containerId, value) => {
					const editor = monacoEditorInstances[containerId];
					if (editor) {
						editor.setValue(value || '');
					}
				};

				const STORAGE_KEY = 'apiProgramEntries';

				const HTTP_METHODS = ['GET', 'POST', 'PUT', 'PATCH', 'DELETE'];

				const form = document.getElementById('entryForm');
				const requestList = document.getElementById('requestList');
				const details = document.getElementById('tabDetails');
				const emptyState = document.getElementById('emptyState');
				const clearButton = document.getElementById('clearButton');
				const newRequestBtn = document.getElementById('newRequestBtn');
				const entryFormSection = document.getElementById('entryFormSection');
				const titleInput = document.getElementById('titleInput');
				const methodSelect = document.getElementById('methodSelect');
				const urlInput = document.getElementById('urlInput');
				const apiKeyInput = document.getElementById('apiKeyInput');
				const headersList = document.getElementById('headersList');
				const addHeaderBtn = document.getElementById('addHeaderBtn');
				const jsonInputContainer = document.getElementById('jsonInput');
				const responseCache = {};

				const headersArrayToObject = (list = []) => {
					return list.reduce((acc, { key, value }) => {
						if (key) {
							acc[key] = value ?? '';
						}
						return acc;
					}, {});
				};

				const serializeHeaders = (list = []) => {
					const obj = headersArrayToObject(list);
					const keys = Object.keys(obj);
					return keys.length ? JSON.stringify(obj) : '';
				};

				const parseHeadersText = (text = '') => {
					if (!text || !text.trim()) return [];
					try {
						const parsed = JSON.parse(text);
						if (Array.isArray(parsed)) {
							return parsed
								.map((item) => ({
									key: item.key ?? '',
									value: item.value ?? '',
								}))
								.filter(({ key, value }) => key || value);
						}
						if (typeof parsed === 'object' && parsed !== null) {
							return Object.entries(parsed).map(([key, value]) => ({
								key,
								value: String(value ?? ''),
							}));
						}
					} catch (_) {
						console.warn('Headers 문자열 파싱 실패', text);
					}
					return [];
				};

				const createHeaderRowElement = ({ key = '', value = '' } = {}) => {
					const row = document.createElement('div');
					row.className = 'header-row';

					const keyInput = document.createElement('input');
					keyInput.type = 'text';
					keyInput.placeholder = 'Key';
					keyInput.value = key;
					keyInput.className = 'header-key';

					const valueInput = document.createElement('input');
					valueInput.type = 'text';
					valueInput.placeholder = 'Value';
					valueInput.value = value;
					valueInput.className = 'header-value';

					const removeBtn = document.createElement('button');
					removeBtn.type = 'button';
					removeBtn.className = 'ghost-btn icon-btn';
					removeBtn.textContent = '×';
					removeBtn.setAttribute('aria-label', '헤더 삭제');
					removeBtn.addEventListener('click', () => {
						row.remove();
						if (!row.parentElement?.querySelector('.header-row')) {
							row.parentElement?.appendChild(createHeaderRowElement());
						}
					});

					row.appendChild(keyInput);
					row.appendChild(valueInput);
					row.appendChild(removeBtn);
					return row;
				};

				const initHeaderList = (container, rows = []) => {
					container.innerHTML = '';
					const safeRows = rows.length ? rows : [{}];
					safeRows.forEach((row) => container.appendChild(createHeaderRowElement(row)));
				};

				const collectHeaderRows = (container) => {
					return Array.from(container.querySelectorAll('.header-row'))
						.map((row) => ({
							key: row.querySelector('.header-key').value.trim(),
							value: row.querySelector('.header-value').value.trim(),
						}))
						.filter(({ key, value }) => key || value);
				};

				initHeaderList(headersList);
				addHeaderBtn.addEventListener('click', () => {
					headersList.appendChild(createHeaderRowElement());
				});

				let entries = [];
				let activeId = '';

				const generateId = () => {
					return typeof crypto !== 'undefined' && crypto.randomUUID
						? crypto.randomUUID()
						: `entry-${Date.now()}-${Math.floor(Math.random() * 1000)}`;
				};

				const parseEntries = () => {
					try {
						const raw = localStorage.getItem(STORAGE_KEY);
						return raw ? JSON.parse(raw) : [];
					} catch (err) {
						console.error('localStorage 파싱 오류', err);
						return [];
					}
				};

				const persistEntries = () => {
					localStorage.setItem(STORAGE_KEY, JSON.stringify(entries));
				};

				const setActive = (id) => {
					activeId = id;
					renderTabs();
					renderDetails();
				};

				const deleteEntry = (id) => {
					entries = entries.filter((entry) => entry.id !== id);
					activeId = activeId === id ? entries[0]?.id ?? '' : activeId;
					persistEntries();
					renderTabs();
					renderDetails();
					if (!entries.length) {
						resetForm();
					}
				};

				const renderTabs = () => {
					requestList.innerHTML = '';

					if (!entries.length) {
						requestList.classList.add('hidden');
						emptyState.classList.remove('hidden');
						details.classList.add('hidden');
						entryFormSection.classList.add('hidden');
						return;
					}

					requestList.classList.remove('hidden');
					emptyState.classList.add('hidden');
					entryFormSection.classList.add('hidden');

					entries.forEach((entry) => {
						const requestItem = document.createElement('div');
						requestItem.className = `request-item ${entry.id === activeId ? 'active' : ''}`;

						const button = document.createElement('button');
						button.type = 'button';
						button.className = 'request-button';
						button.innerHTML = `
							<span class="request-method">${entry.method || 'GET'}</span>
							<span class="request-title">${entry.title}</span>
						`;
						button.addEventListener('click', () => setActive(entry.id));

						const deleteBtn = document.createElement('button');
						deleteBtn.type = 'button';
						deleteBtn.className = 'request-close';
						deleteBtn.setAttribute('aria-label', `${entry.title} 삭제`);
						deleteBtn.textContent = '×';
						deleteBtn.addEventListener('click', (event) => {
							event.stopPropagation();
							deleteEntry(entry.id);
						});

						requestItem.appendChild(button);
						requestItem.appendChild(deleteBtn);
						requestList.appendChild(requestItem);
					});
				};

				const buildEditableRow = (labelText, inputEl) => {
					const wrapper = document.createElement('div');
					wrapper.className = 'detail-row column editable';

					const label = document.createElement('label');
					label.textContent = labelText;
					label.setAttribute('for', inputEl.id);

					wrapper.appendChild(label);
					wrapper.appendChild(inputEl);
					return wrapper;
				};

				const renderResponseBox = (container, response) => {
					if (!response) {
						container.innerHTML = '<p class="response-empty">아직 전송 결과가 없습니다.</p>';
						return;
					}

					const { status, ok, timestamp, headers, body, error } = response;
					const statusClass = ok ? 'status-badge success' : 'status-badge error';

					const headerEntries = Object.entries(headers || {});
					const headerHtml = headerEntries.length
						? `<div class="response-headers"><h4>Headers</h4><pre>${headerEntries
								.map(([key, value]) => `${key}: ${value}`)
								.join('\n')}</pre></div>`
						: '';

					const bodyHtml = body
						? `<div class="response-body"><h4>Body</h4><pre>${body}</pre></div>`
						: '';

					const errorHtml = error ? `<p class="response-error">${error}</p>` : '';

					container.innerHTML = `
						<div class="response-meta">
							<span class="${statusClass}">${status}</span>
							<span>${new Date(timestamp).toLocaleString()}</span>
						</div>
						${errorHtml}
						${headerHtml}
						${bodyHtml}
					`;
				};

				const sendRequest = async ({ id, method, url, headersArray = [], apiKey, payload, buttonEl, responseEl }) => {
					if (!url) {
						alert('URL을 입력해주세요.');
						return;
					}

					buttonEl.disabled = true;
					const originalText = buttonEl.textContent;
					buttonEl.textContent = '전송 중...';

					const headers = headersArrayToObject(headersArray);
					if (apiKey && !headers['X-API-Key']) {
						headers['X-API-Key'] = apiKey;
					}
					const options = {
						method,
						headers,
					};

					if (!['GET', 'HEAD'].includes(method)) {
						let parsedBody = payload;
						try {
							parsedBody = payload ? JSON.stringify(JSON.parse(payload)) : '';
						} catch (error) {
							alert('Json-data 형식이 올바르지 않습니다.');
							buttonEl.disabled = false;
							buttonEl.textContent = originalText;
							return;
						}

						options.body = parsedBody || '';
						if (parsedBody && !headers['Content-Type']) {
							headers['Content-Type'] = 'application/json';
						}
					}

					try {
						const response = await fetch(url, options);
						const text = await response.text();
						let prettyBody = text;
						try {
							prettyBody = JSON.stringify(JSON.parse(text), null, 2);
						} catch (_) {
							// keep raw text
						}

						const collectedHeaders = {};
						response.headers.forEach((value, key) => {
							collectedHeaders[key] = value;
						});

						responseCache[id] = {
							ok: response.ok,
							status: `${response.status} ${response.statusText}`,
							timestamp: Date.now(),
							headers: collectedHeaders,
							body: prettyBody,
							error: '',
						};
					} catch (error) {
						responseCache[id] = {
							ok: false,
							status: 'NETWORK ERROR',
							timestamp: Date.now(),
							headers: {},
							body: '',
							error: error.message || '요청 중 오류가 발생했습니다.',
						};
					} finally {
						buttonEl.disabled = false;
						buttonEl.textContent = originalText;
						renderResponseBox(responseEl, responseCache[id]);
					}
				};

				const renderDetails = () => {
					const current = entries.find((entry) => entry.id === activeId);

					if (!current) {
						details.classList.add('hidden');
						return;
					}

					details.classList.remove('hidden');
					details.innerHTML = '';

					// 요청 영역
					const requestSection = document.createElement('div');
					requestSection.className = 'request-section';

					// 상단: Method + URL + Send 버튼 (Postman 스타일)
					const requestBar = document.createElement('div');
					requestBar.className = 'request-bar';

					const detailMethod = document.createElement('select');
					detailMethod.id = 'detailMethod';
					detailMethod.className = 'request-method-select';
					HTTP_METHODS.forEach((method) => {
						const option = document.createElement('option');
						option.value = method;
						option.textContent = method;
						detailMethod.appendChild(option);
					});
					detailMethod.value = current.method || 'GET';
					detailMethod.required = true;

					const detailUrl = document.createElement('input');
					detailUrl.id = 'detailUrl';
					detailUrl.type = 'url';
					detailUrl.className = 'request-url-input';
					detailUrl.value = current.url;
					detailUrl.required = true;
					detailUrl.placeholder = 'https://api.example.com/users';

					const sendBtn = document.createElement('button');
					sendBtn.type = 'button';
					sendBtn.className = 'send-button';
					sendBtn.textContent = 'Send';

					requestBar.appendChild(detailMethod);
					requestBar.appendChild(detailUrl);
					requestBar.appendChild(sendBtn);

					// 탭 영역
					const tabsContainer = document.createElement('div');
					tabsContainer.className = 'tabs-container';

					const tabsNav = document.createElement('div');
					tabsNav.className = 'tabs-nav';

					const paramsTab = document.createElement('button');
					paramsTab.type = 'button';
					paramsTab.className = 'tab-nav-item';
					paramsTab.textContent = 'Params';
					paramsTab.dataset.tab = 'params';

					const headersTab = document.createElement('button');
					headersTab.type = 'button';
					headersTab.className = 'tab-nav-item active';
					headersTab.textContent = 'Headers';
					headersTab.dataset.tab = 'headers';

					const bodyTab = document.createElement('button');
					bodyTab.type = 'button';
					bodyTab.className = 'tab-nav-item';
					bodyTab.textContent = 'Body';
					bodyTab.dataset.tab = 'body';

					tabsNav.appendChild(paramsTab);
					tabsNav.appendChild(headersTab);
					tabsNav.appendChild(bodyTab);

					const tabsContent = document.createElement('div');
					tabsContent.className = 'tabs-content';

					// Params 탭 (현재는 비어있음)
					const paramsPanel = document.createElement('div');
					paramsPanel.className = 'tab-panel hidden';
					paramsPanel.id = 'tab-panel-params';
					paramsPanel.innerHTML = '<p class="tab-placeholder">Params 기능은 추후 추가 예정입니다.</p>';

					// Headers 탭
					const headersPanel = document.createElement('div');
					headersPanel.className = 'tab-panel';
					headersPanel.id = 'tab-panel-headers';

					const detailHeaderList = document.createElement('div');
					detailHeaderList.className = 'headers-list';

					const detailHeaderAddBtn = document.createElement('button');
					detailHeaderAddBtn.type = 'button';
					detailHeaderAddBtn.className = 'ghost-btn slim-btn';
					detailHeaderAddBtn.textContent = '헤더 추가';
					detailHeaderAddBtn.addEventListener('click', () => {
						detailHeaderList.appendChild(createHeaderRowElement());
					});

					initHeaderList(detailHeaderList, current.headers?.length ? current.headers : parseHeadersText(current.headersText));

					headersPanel.appendChild(detailHeaderList);
					headersPanel.appendChild(detailHeaderAddBtn);

					// Body 탭
					const bodyPanel = document.createElement('div');
					bodyPanel.className = 'tab-panel hidden';
					bodyPanel.id = 'tab-panel-body';

					const detailApiKey = document.createElement('input');
					detailApiKey.id = 'detailApiKey';
					detailApiKey.type = 'text';
					detailApiKey.className = 'detail-edit-input';
					detailApiKey.value = current.apiKey || '';
					detailApiKey.placeholder = 'API Key (예: sk_live_xxx)';

					const apiKeyLabel = document.createElement('label');
					apiKeyLabel.textContent = 'API Key';
					apiKeyLabel.setAttribute('for', 'detailApiKey');
					apiKeyLabel.className = 'field-label';

					const detailJsonContainer = document.createElement('div');
					detailJsonContainer.id = 'detailJson';
					detailJsonContainer.className = 'monaco-editor-container';
					detailJsonContainer.style.height = '300px';

					const jsonLabelContainer = document.createElement('div');
					jsonLabelContainer.className = 'json-label-container';
					const jsonLabel = document.createElement('label');
					jsonLabel.textContent = 'JSON Data';
					jsonLabel.setAttribute('for', 'detailJson');
					jsonLabel.className = 'field-label';

					const formatJsonBtn = document.createElement('button');
					formatJsonBtn.type = 'button';
					formatJsonBtn.className = 'format-json-btn';
					formatJsonBtn.textContent = '포맷';
					formatJsonBtn.title = 'JSON 포맷팅 (Ctrl+Shift+F)';
					formatJsonBtn.addEventListener('click', async () => {
						const editor = monacoEditorInstances['detailJson'];
						if (editor) {
							try {
								editor.getAction('editor.action.formatDocument').run();
							} catch (error) {
								alert('포맷팅 중 오류가 발생했습니다.');
							}
						}
					});

					jsonLabelContainer.appendChild(jsonLabel);
					jsonLabelContainer.appendChild(formatJsonBtn);

					bodyPanel.appendChild(apiKeyLabel);
					bodyPanel.appendChild(detailApiKey);
					bodyPanel.appendChild(jsonLabelContainer);
					bodyPanel.appendChild(detailJsonContainer);

					// Monaco Editor 초기화 (비동기)
					setTimeout(async () => {
						await initMonacoEditor('detailJson', current.jsonData || '');
					}, 100);

					tabsContent.appendChild(paramsPanel);
					tabsContent.appendChild(headersPanel);
					tabsContent.appendChild(bodyPanel);

					tabsContainer.appendChild(tabsNav);
					tabsContainer.appendChild(tabsContent);

					// 탭 전환 기능
					const switchTab = (tabName) => {
						document.querySelectorAll('.tab-nav-item').forEach((btn) => btn.classList.remove('active'));
						document.querySelectorAll('.tab-panel').forEach((panel) => panel.classList.add('hidden'));
						document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');
						document.getElementById(`tab-panel-${tabName}`).classList.remove('hidden');
					};

					paramsTab.addEventListener('click', () => switchTab('params'));
					headersTab.addEventListener('click', () => switchTab('headers'));
					bodyTab.addEventListener('click', () => switchTab('body'));

					// Title 입력 (상단에 작게 표시)
					const titleBar = document.createElement('div');
					titleBar.className = 'title-bar';

					const detailTitle = document.createElement('input');
					detailTitle.id = 'detailTitle';
					detailTitle.className = 'title-input';
					detailTitle.value = current.title;
					detailTitle.required = true;
					detailTitle.placeholder = '요청 이름';

					const saveBtn = document.createElement('button');
					saveBtn.type = 'button';
					saveBtn.className = 'save-button';
					saveBtn.textContent = '저장';

					titleBar.appendChild(detailTitle);
					titleBar.appendChild(saveBtn);

					requestSection.appendChild(titleBar);
					requestSection.appendChild(requestBar);
					requestSection.appendChild(tabsContainer);

					// 응답 영역
					const responsePanel = document.createElement('section');
					responsePanel.className = 'response-panel';
					const responseTitle = document.createElement('h3');
					responseTitle.textContent = '응답';
					const responseContent = document.createElement('div');
					responseContent.className = 'response-content';
					responsePanel.appendChild(responseTitle);
					responsePanel.appendChild(responseContent);

					renderResponseBox(responseContent, responseCache[current.id]);

					// 저장 기능
					const saveRequest = () => {
						const updated = {
							...current,
							title: detailTitle.value.trim(),
							method: detailMethod.value,
							url: detailUrl.value.trim(),
							headers: collectHeaderRows(detailHeaderList),
							apiKey: detailApiKey.value.trim(),
							jsonData: getMonacoValue('detailJson').trim(),
						};

						if (!updated.title || !updated.method || !updated.url || !updated.jsonData) {
							alert('모든 필수를 입력해주세요.');
							return;
						}

						const serializedHeaders = serializeHeaders(updated.headers);
						updated.headersText = serializedHeaders;

						entries = entries.map((entry) => (entry.id === updated.id ? updated : entry));
						persistEntries();
						setActive(updated.id);
					};

					saveBtn.addEventListener('click', saveRequest);

					// 전송 기능
					sendBtn.addEventListener('click', () => {
						sendRequest({
							id: current.id,
							method: detailMethod.value,
							url: detailUrl.value.trim(),
							headersArray: collectHeaderRows(detailHeaderList),
							apiKey: detailApiKey.value.trim(),
							payload: getMonacoValue('detailJson').trim(),
							buttonEl: sendBtn,
							responseEl: responseContent,
						});
					});

					details.appendChild(requestSection);
					details.appendChild(responsePanel);
				};

				const enableCodeEditor = (textarea) => {
					if (!textarea) return;

					const TAB = '    '; // 4 spaces
					const getLineStart = (text, pos) => {
						let start = pos;
						while (start > 0 && text[start - 1] !== '\n') {
							start--;
						}
						return start;
					};

					const getLineEnd = (text, pos) => {
						let end = pos;
						while (end < text.length && text[end] !== '\n') {
							end++;
						}
						return end;
					};

					const getSelectedLines = (text, start, end) => {
						const lineStart = getLineStart(text, start);
						const lineEnd = getLineEnd(text, end);
						const selectedText = text.substring(lineStart, lineEnd);
						const lines = selectedText.split('\n');
						return { lines, lineStart, lineEnd, firstLineStart: lineStart };
					};

					const indentLines = (text, start, end, indent) => {
						const { lines, lineStart, lineEnd } = getSelectedLines(text, start, end);
						const indentedLines = lines.map((line, index) => {
							if (line.trim() === '' && index < lines.length - 1) return line;
							return indent + line;
						});
						const newText =
							text.substring(0, lineStart) +
							indentedLines.join('\n') +
							text.substring(lineEnd);
						const cursorOffset = indent.length;
						return {
							newText,
							newStart: start + (start === lineStart ? cursorOffset : 0),
							newEnd: end + cursorOffset * lines.length,
						};
					};

					const unindentLines = (text, start, end) => {
						const { lines, lineStart, lineEnd } = getSelectedLines(text, start, end);
						let totalRemoved = 0;
						const unindentedLines = lines.map((line, index) => {
							if (line.trim() === '' && index < lines.length - 1) return line;
							if (line.startsWith(TAB)) {
								totalRemoved += TAB.length;
								return line.substring(TAB.length);
							}
							if (line.startsWith(' ')) {
								const spaces = line.match(/^ +/)?.[0] || '';
								const toRemove = Math.min(spaces.length, 4);
								totalRemoved += toRemove;
								return line.substring(toRemove);
							}
							return line;
						});
						const newText =
							text.substring(0, lineStart) +
							unindentedLines.join('\n') +
							text.substring(lineEnd);
						return {
							newText,
							newStart: Math.max(lineStart, start - (start === lineStart ? TAB.length : 0)),
							newEnd: Math.max(lineStart, end - totalRemoved),
						};
					};

					textarea.addEventListener('keydown', (event) => {
						const { selectionStart, selectionEnd, value } = textarea;
						const isMultiLine = selectionStart !== selectionEnd;

						// Tab 키: 들여쓰기
						if (event.key === 'Tab' && !event.shiftKey) {
							event.preventDefault();
							if (isMultiLine) {
								// 여러 줄 선택 시 모든 줄에 들여쓰기
								const { newText, newStart, newEnd } = indentLines(value, selectionStart, selectionEnd, TAB);
								textarea.value = newText;
								textarea.selectionStart = newStart;
								textarea.selectionEnd = newEnd;
							} else {
								// 단일 커서: 탭 삽입
								const before = value.slice(0, selectionStart);
								const after = value.slice(selectionEnd);
								const nextCursor = selectionStart + TAB.length;
								textarea.value = `${before}${TAB}${after}`;
								textarea.selectionStart = textarea.selectionEnd = nextCursor;
							}
						}

						// Shift+Tab: 내어쓰기
						if (event.key === 'Tab' && event.shiftKey) {
							event.preventDefault();
							if (isMultiLine) {
								// 여러 줄 선택 시 모든 줄에서 내어쓰기
								const { newText, newStart, newEnd } = unindentLines(value, selectionStart, selectionEnd);
								textarea.value = newText;
								textarea.selectionStart = newStart;
								textarea.selectionEnd = newEnd;
							}
						}

						// Enter: 자동 들여쓰기 유지
						if (event.key === 'Enter') {
							const before = value.substring(0, selectionStart);
							const lineStart = getLineStart(value, selectionStart);
							const currentLine = value.substring(lineStart, selectionStart);
							const indentMatch = currentLine.match(/^(\s*)/);
							const currentIndent = indentMatch ? indentMatch[1] : '';

							// 중괄호나 대괄호 뒤에서 Enter를 누르면 추가 들여쓰기
							const lastChar = currentLine.trim().slice(-1);
							const shouldIndent = lastChar === '{' || lastChar === '[';

							setTimeout(() => {
								const newPos = textarea.selectionStart;
								const beforeNew = textarea.value.substring(0, newPos);
								const afterNew = textarea.value.substring(newPos);
								const newIndent = shouldIndent ? currentIndent + TAB : currentIndent;
								textarea.value = beforeNew + newIndent + afterNew;
								textarea.selectionStart = textarea.selectionEnd = newPos + newIndent.length;
							}, 0);
						}

						// Backspace: 탭 단위로 삭제
						if (event.key === 'Backspace') {
							if (selectionStart === selectionEnd) {
								const before = value.substring(0, selectionStart);
								if (before.endsWith(TAB)) {
									event.preventDefault();
									textarea.value =
										value.substring(0, selectionStart - TAB.length) +
										value.substring(selectionEnd);
									textarea.selectionStart = textarea.selectionEnd = selectionStart - TAB.length;
								}
							}
						}
					});
				};

				// 새 요청 폼의 Monaco Editor 초기화
				const formatJsonInputBtn = document.getElementById('formatJsonInputBtn');
				if (formatJsonInputBtn) {
					formatJsonInputBtn.addEventListener('click', async () => {
						const editor = monacoEditorInstances['jsonInput'];
						if (editor) {
							try {
								editor.getAction('editor.action.formatDocument').run();
							} catch (error) {
								alert('포맷팅 중 오류가 발생했습니다.');
							}
						}
					});
				}

				// 페이지 로드 후 Monaco Editor 초기화
				window.addEventListener('DOMContentLoaded', async () => {
					await initMonacoEditor('jsonInput', '');
				});

				newRequestBtn.addEventListener('click', () => {
					entryFormSection.classList.remove('hidden');
					details.classList.add('hidden');
					requestList.classList.add('hidden');
					emptyState.classList.add('hidden');
					titleInput.focus();
				});

				const resetForm = () => {
					form.reset();
					initHeaderList(headersList);
					setMonacoValue('jsonInput', '');
					titleInput.focus();
				};

				form.addEventListener('submit', (event) => {
					event.preventDefault();

					const title = titleInput.value.trim();
					const method = methodSelect.value;
					const url = urlInput.value.trim();
					const headers = collectHeaderRows(headersList);
					const headersText = serializeHeaders(headers);
					const apiKey = apiKeyInput.value.trim();
					const jsonData = getMonacoValue('jsonInput').trim();

					if (!title || !method || !url || !jsonData) {
						return;
					}

					const newEntry = {
						id: generateId(),
						title,
						method,
						url,
						headers,
						headersText,
						apiKey,
						jsonData,
					};
					entries = [...entries, newEntry];
					persistEntries();
					resetForm();
					entryFormSection.classList.add('hidden');
					setActive(newEntry.id);
				});

				clearButton.addEventListener('click', () => {
					if (!entries.length) return;
					const confirmed = confirm('저장된 모든 항목을 삭제할까요?');
					if (!confirmed) return;
					entries = [];
					activeId = '';
					persistEntries();
					renderTabs();
					renderDetails();
					resetForm();
				});

				const init = async () => {
					entries = parseEntries().map((entry) => {
						const normalizedHeaders = Array.isArray(entry.headers)
							? entry.headers
							: parseHeadersText(entry.headersText);
						const serialized = entry.headersText || serializeHeaders(normalizedHeaders);
						return {
							...entry,
							method: entry.method || 'GET',
							headers: normalizedHeaders,
							headersText: serialized,
							apiKey: entry.apiKey || '',
						};
					});
					activeId = entries[0]?.id ?? '';
					renderTabs();
					renderDetails();
					if (entries.length === 0) {
						entryFormSection.classList.remove('hidden');
						await initMonacoEditor('jsonInput', '');
						titleInput.focus();
					}
				};

				// DOMContentLoaded 대신 즉시 실행
				if (document.readyState === 'loading') {
					document.addEventListener('DOMContentLoaded', init);
				} else {
					init();
				}
			})();
		</script>
	</body>
</html>
